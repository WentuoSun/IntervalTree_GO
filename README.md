# 实现区间树

**实现区间树的插入、删除、查询和层序遍历输出**

区间树作为红黑树的一种扩展，插入删除基本算法与红黑树大致相同。
只需添加对区间树max值的维护即可



先从简单的说起，插入和删除时为了维护其红黑性质，都需要在最后调用`InsertFixup()`， `DeleteFixup()`,

两函数内部都是对红黑树的左旋，右旋以及节点颜色的调整，因此只需要在对应的左旋右旋函数中维护好max值，就不需要在这两个函数中添加额外内容。

## 左旋右旋
无论是左旋还是右旋，都只是影响了旋转节点和其其中一个子节点的位置。而该节点和其子节点的其他子树的max值并没有受到影响，因此只需要在左旋右旋的最后对该旋转节点和其子节点的max重新计算即可。

例如：`LeftRotate(tx *INode)` tx为旋转节点，函数内部`ty = tx.right` 。旋转结束后，tx成为ty的左孩子。因此只需在红黑树左旋代码的基础上，在最后添加两行代码：

先算tx
`tx.max = MaxofInt( tx.High, tx.Left.Max, tx.Right.Max) `

再算ty
`ty.max = MaxofInt( ty.High, ty.Left.Max, ty.Right.Max) `

右旋类似。

## 插入

插入过程中，第一步便是根据红黑树的二叉搜索性质，找到新节点需要插入的位置，这也就意味着，从根节点开始找到需要插入位置的过程已经将新节点的所有祖先节点全部遍历了一遍，如果后期需要调整（左旋右旋），那还遍历了一次新节点的兄弟节点。

所以只需要在从根向下寻找的过程中，将新节点的Max(Max = High) 值与其所有祖先节点作比较，如果新节点的大，则用新节点的max值替换原max值，反之新节点的插入不会影响到该祖先节点的max，不用更改。

这里会涉及到如果后期调整时进行了左旋和右旋，原来的祖先节点有一个会变成其兄弟节点，但是这个问题在左旋右旋函数中已经被解决。因为旋转后会重新计算旋转节点及其相应子节点的max，即使更改了，也可以该回去。

还有一种方法： 就是在插入和调整结束后，从新节点的父节点开始沿树向上比较其祖先节点与新节点max值的大小关系，如果新节点大，则重新计算祖先节点的max值，这样也是可以的，但是与其再从新节点到树根走一遍，不如就在从树根找到插入位置的时候就将这个问题解决。


## 删除

删除的情况最为复杂，先从简单的说起。

1、
整个删除算法都是以被删除节点的子节点情况的不同分类进行处理。
而无论如何分类，节点的删除都有可能影响该节点的所有祖先节点的max值。

因此，在程序的最后，需要从被删除节点的父节点开始，一直沿树向上寻找，若该祖先max值等于被删除节点的max，则重新计算该祖先节点的max，如此循环，知道到达根节点，或者祖先节点的max大于被删除节点。循环结束

2、
被删除节点有一个孩子为Nil节点或者其后继节点为其右孩子，
这三种情况对于维护max来说，是相同的。这三种情况，算法中都是将需要的节点替换`TranPlant()`到被删除节点的位置而不改变其子树的性质

因此只需要在替换结束后，对该位置的新节点的max值重新计算一次即可

3、
最为复杂的情况，被删除节点tx左右孩子非空，且其后继节点ty不是该节点的右孩子，此时不仅需要将ty TranPlant到tx的位置里，还需要在此之前将ty的右子树替换到ty的位置上。

所以经过两次替换被可能max瘦到影响的就有两个节点，一是原tx位置的新节点，这与2中相同，二是tx的后继ty的父节点。

具体实现见`tree.go`中的`Delete()`函数

初次学习使用go语言，费了很大功夫。

为了搞清楚如何维护max值，呆呆的想了很久，写下这个备忘录。



2019.05.11